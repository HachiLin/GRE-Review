## 第1章 计算机系统概述



### 1.3 计算机性能指标

#### 1.3.1 计算机的主要性能指标

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2010-12,2011-12,2011-15,2012-12,2013-12,2014-12</font>

1. **机器字长**

&emsp;&emsp;机器字长是指计算机**进行一次整数运算(即定点整数运算)**所能处理的**二进制数据的位数**，通常与**CPU的寄存器位数**、**加法器**有关。机器字长一般等于内部寄存器的大小，**字长越长，数的表示范围越大，计算精度越高**。计算机字长通常选定为字节(8位)的整数倍。不同计算机，字长可以不同。

**【注】：**

> **机器字长**：CPU一次能处理数据的位数，通常与CPU的寄存器位数有关。
>
> **存储字长**：存储器中一个存储单元(存储地址)所存储的二进制代码的位数，即存储器中的MDR的位数。
>
> **指令字长**：计算机指令字的位数。
>
> **数据字长**：计算机数据存储所占用的位数 

2. **数据通路带宽**

&emsp;&emsp;数据通路带宽是数据总线**一次所能进行并行传送信息的位数**。**这里所说的数据通路宽度是指外部数据总线的宽度**，它与CPU内部的数据总线宽度(内部寄存器的大小)有可能不同。

**【注】**各个子系统通过数据总线连接形成的数据传送路径称为数据通路。

3. **主存容量**

&emsp;&emsp;主存容量是指主存存储器所能存储的最大容量，**通常以字节来衡量**，也可以用**字数&times;字长(如512k&times;16位)**来表示存储容量。其中，**MAR的位数反映存储单元的个数**，MAR的位数**反映可寻址范围的最大值(而不一定是实际存储器的存储容量)**。

- 例子

<img src="C:\Users\HP\Desktop\组成原理\1.3.1-1.png" alt="1.3.1-1" style="zoom:80%;" />

4. **运算速率**

**（1）吞吐量和响应时间**

- **吞吐量**：指系统在单位时间被处理请求的数量。它取决于信息能多快地输入内存，CPU能多块地取指令，数据能多块地从内存取出或存入，以及所得结果能多块地从内存送给一台外部设备。这些步骤中的每步都关系到主存，因此**系统吞吐量主要取决于主存的存储周期**。

- **响应时间**：指从用户向计算机发送一个请求，到系统对该请求做出响应并获得所需结果的等待时间。通常包括**CPU时间**(运行一个程序花费的时间)与**等待时间**(用与磁盘访问、存储器访问、I/O操作、操作系统开销等的时间)。

**（2）主频和CPU时钟周期**

- **CPU时钟周期**：通常为**节拍脉冲或T周期**，即**主频的倒数**，它**是CPU中最小的时间单位**，每个动作至少需要1个时钟周期。

- **主频(CPU的时钟频率)**：机器内部主时钟的频率，是衡量机器速度的重要参数。主频的倒数是CPU的时钟周期。**对于同一型号的计算机，其主频越高，完成指令的一个执行步骤所需的时间就越短，执行指令的速度就越快**。

**【注】**主频通常以MHz(兆赫兹)为单位，1HZ表示每秒一个时钟周期。

**（3）CPI(Clock cycle Per Instruction)**：即执行一条指令所需的时钟周期数。

**（4）CPU执行时间**：指运行一个程序所花费的时间
$$
CPU的执行时间=CPU时钟周期数/主频=(指令条数\times CPI)/主频
$$
上述表明，CPU的性能(执行时间)取决于**① 主频 ② CPI ③ 指令条数**

**（5）MIPS、MFLOPS、GLOPS和TFLOPS**

- **MIPS(Million Instructions Per Second)**，即每秒执行多少百万条指令。

$$
MIPS=指令条数/(执行时间\times10^6)=主频/CPI
$$

- **MFLOPS(Mega Floating-point Operations Per Second)**，即每秒执行多少百万次浮点运算。

$$
MFLOPS=浮点操作次数/(执行时间\times10^6)
$$

- **GFLOPS(Giga Floating-point Operations Per Second)**，即每秒执行多少十亿次浮点运算。

$$
GFLOPS=浮点操作次数/(执行时间\times10^9)
$$

- **TFLOPS**(Tera Floating-point Operations Per Second)，即每秒执行多少万亿次浮点运算。

$$
TFLOPS=浮点操作次数/(执行时间\times10^{12})
$$

#### 1.3.2 几个专业术语

<img src="C:\Users\HP\Desktop\组成原理\1.3.2-1.png" alt="1.3.2-1" style="zoom:80%;" />





## 第2章 数据的表示与运算

### 2.1 数制与编码



#### 2.1.4 字符与字符串



3. **字符串的存放**

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2012-15</font>

&emsp;&emsp;字符串是指连续的一串字符，通常方式下，它们占用主存中连续的多个字节，每个字节存储一个字符。主存字节由2B或4B组成时，在同一个主存字中，既可以按**先存储低位字节，后存储高位字节的顺序(即从低位字节向高位字节)**存放字符串的内容(**小端模式**)，又可以按**先存储高位字节，后存储高位字节的顺序(即从高位字节向低位字节)**存放字符串的内容(**大端模式**)。

- **例子**

<img src="C:\Users\HP\Desktop\组成原理\2.4.1-1.png" alt="2.4.1-1" style="zoom:80%;" />



#### 2.1.5 校验码



2. **海明(汉明)校验码**

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2013-15</font>

例子：在$n=4,k=3$时，求1010的海明码。

**（1）确定海明码的位数**

设$n$为有效信息的位数，$k$为校验位的位数，则信息位$n$和校验位$k$应满足
$$
n+k \le 2^k -1
$$
&emsp;&emsp;海明码位数为$n+k = 7 \le 2^3 -1$成立，则$n、k$有效。设信息位为$D_4D_3D_2D_1(1010)$，共4位，校验位为$P_3P_2P_1$，共3位，对应的海明码为$H_7H_6H_5H_4H_3H_2H_1$。

**（2）确定校验位的分布**

规定校验位$P_i$在海明位号为$2^{i-1}$的位置上，其余各位为信息位，因此有

<img src="C:\Users\HP\Desktop\组成原理\2.1.5-1.png" alt="2.1.5-1" style="zoom:80%;" />

将信息位按原来的顺序插入，则海明码各位的分布如下：

<img src="C:\Users\HP\Desktop\组成原理\2.1.5-2.png" alt="2.1.5-2" style="zoom:80%;" />

**（3）分组以形成校验关系**

&emsp;&emsp;每个数据位用多个校验位进行校验，但要满足条件：被校验数据位的海明位号等于校验该数据位的各校验位海明位号之和。另外，校验位不需再被校验。分组形成的校验关系如下：

<img src="C:\Users\HP\Desktop\组成原理\2.1.5-3.png" alt="2.1.5-3" style="zoom:90%;" />

**（4）校验位取值**

校验位$P_i$的值为第$i$组(由该校验位校验的数据位)所有位求异或。

根据3）中的分组由

<img src="C:\Users\HP\Desktop\组成原理\2.1.5-4.png" alt="2.1.5-4" style="zoom:80%;" />

所以，1010对应的海明码为1010010。

**（5）海明码的校验原理**

&emsp;&emsp;每个校验组分别利用校验位和参与形成该校验位的信息位进行奇偶校验检查，构成$k$个校验方程

<img src="C:\Users\HP\Desktop\组成原理\2.1.5-5.png" alt="2.1.5-5" style="zoom:80%;" />

若$S_3S_2S_1=000$ 则说明无错；否则说明出错，且这个数就是错位的位号，如$S_3S_2S_1=001$说明第1位出错，即$H_1$出错，直接将该位取反就达到了纠错的目的。



### 2.2 定点数的表示与运算

#### 2.2.1 定点数的表示

<font color='#0099ff' size=5 face="黑体">大题：</font><font color='#FF0000' size=4 face="黑体">2011-43</font>

1. **无符号数和有符号数的表示**

**1）无符号数**：指整个机器字长的全部二进制位均为数值位，没有符号位，相当于数的绝对值。若机器字长为8位，则数的表示范围为0~2<sup>8</sup>，即0~255。

**2）有符号数**：通常约定二进制数的最高位为符号位，即将符号位放在有效数字的前面，组成有符号数。有符号数的机器表示有**原码**、**补码**、**反码**和**移码**。用$[X]_{原}$表示原码，$[X]_{补}$表示补码，$[X]_{反}$表示反码，$[X]_{移}$表示移码。



2. **机器数的定点表示**

**（1）定点小数**

&emsp;&emsp;定点小数是纯小数，约定小数点位置在符号位之后、有效数值部分之前。设机器字长为n+1位，如图所示：

<img src="C:\Users\HP\Desktop\组成原理\2.2.1-1.png" alt="2.2.1-1" style="zoom:80%;" />

**（2）定点整数**

&emsp;&emsp;定点整数是纯整数，约定小数点位置在有效数值最低位之后。设机器字长为n+1位，如图所示：

<img src="C:\Users\HP\Desktop\组成原理\2.2.1-2.png" alt="2.2.1-2" style="zoom:80%;" />

<img src="C:\Users\HP\Desktop\组成原理\2.2.1-3.png" alt="2.2.1-3" style="zoom:80%;" />



3. **原码、补码、反码、移码**

**（1）原码表示法**

- **纯小数的原码定义**

<img src="C:\Users\HP\Desktop\组成原理\2.2.1-4.png" alt="2.2.1-4" style="zoom:80%;" />

例子：

<img src="C:\Users\HP\Desktop\组成原理\2.2.1-5.png" alt="2.2.1-5" style="zoom:80%;" />

表示范围：若字长为n+1，$-(1-2^{-n})\le x \le 1-2^{-n}$（关于原点对称）

- **纯整数的原码定义**

<img src="C:\Users\HP\Desktop\组成原理\2.2.1-6.png" alt="2.2.1-6" style="zoom:80%;" />

例子：

<img src="C:\Users\HP\Desktop\组成原理\2.2.1-7.png" alt="2.2.1-7" style="zoom:80%;" />

表示范围：若字长为n+1，$-(2^n-1)\le x \le 2^n -1$（关于原点对称）

**【注】**真值的原码表示有正零和负零两种形式，即$[+0]_{原}=00000$和$[-0]_{原}=10000$

**（2）补码表示法**

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2010-13,2014-13</font>

- **纯小数的补码定义**

<img src="C:\Users\HP\Desktop\组成原理\2.2.1-8.png" alt="2.2.1-8" style="zoom:80%;" />

例子：

<img src="C:\Users\HP\Desktop\组成原理\2.2.1-9.png" alt="2.2.1-9" style="zoom:80%;" />

表示范围：若字长为n+1，$-1\le x \le 1-2^{-n}$（比原码多表示-1）

- **纯整数的补码定义**

<img src="C:\Users\HP\Desktop\组成原理\2.2.1-10.png" alt="2.2.1-10" style="zoom:80%;" />

例子：

<img src="C:\Users\HP\Desktop\组成原理\2.2.1-11.png" alt="2.2.1-11" style="zoom:80%;" />

表示范围：若字长为n+1，$-2^n \le x \le 2^n-1$（比原码多表示$-2^n$）

**【注】**真值零的补码表示是唯一的，即$[+0]_{补}=[-0]_{补}=0.0000$

- **由原码求补码**

<img src="C:\Users\HP\Desktop\组成原理\2.2.1-12.png" alt="2.2.1-12" style="zoom:80%;" />

- **补码的算术移位**

将$[x]_{补}$的符号位与数值一起右移一位并保持原符号位的值不变，可实现除法功能(除以2)。

变形补码，又称为模4补码，双符号位的补码小数，其定义为

<img src="C:\Users\HP\Desktop\组成原理\2.2.1-13.png" alt="2.2.1-13" style="zoom:80%;" />

模4补码双符号位00表示正，11表示负，用在完成算术运算的ALU部件中。

**（3）反码表示**

反码通常用来作为原码求补码或补码求原码的中间过度。

- **纯小数的反码定义**

<img src="C:\Users\HP\Desktop\组成原理\2.2.1-15.png" alt="2.2.1-15" style="zoom:80%;" />

例子：

<img src="C:\Users\HP\Desktop\组成原理\2.2.1-14.png" alt="2.2.1-14" style="zoom:80%;" />

表示范围：若字长为n+1，即$-(1-2^{-n}) \le x \le 1-2^{-n}$（关于原点对称）

**【注】**真值零的反码表示不唯一，负数的反码符号为“1”，数值部分求反，$[+0]_{反}=0.0000$，$[-0]_{反}=1.1111$

- **纯整数的反码定义**

<img src="C:\Users\HP\Desktop\组成原理\2.2.1-16.png" alt="2.2.1-16" style="zoom:80%;" />

例子：

<img src="C:\Users\HP\Desktop\组成原理\2.2.1-17.png" alt="2.2.1-17" style="zoom:80%;" />

表示范围：若字长为n+1，即$-(2^n-1)\le x\le 2^n-1$（关于原点对称）

- **真值、原码、补码及$[-x]_{补}$的转换规律**

<img src="C:\Users\HP\Desktop\组成原理\2.2.1-18.png" alt="2.2.1-18" style="zoom:80%;" />

**（4）移码表示法**

移码常用来表示浮点数的阶码，它只能表示整数。
$$
[x]_{移}=2^n+x\quad (2^n > x\ge -2^n,其中机器字长为n+1)
$$
例子：

<img src="C:\Users\HP\Desktop\组成原理\2.2.1-19.png" alt="2.2.1-19" style="zoom:80%;" />

- **移码的特点**

<img src="C:\Users\HP\Desktop\组成原理\2.2.1-20.png" alt="2.2.1-20" style="zoom:80%;" />



#### 2.2.2 定点数的运算

1. **定点数的移位运算**

**（1）算术移位**

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2013-14</font>

&emsp;&emsp;算术移位的对象是**有符号数**，在移位过程中符号位保持不变。

<img src="C:\Users\HP\Desktop\组成原理\2.2.2-1.png" alt="2.2.2-1" style="zoom:90%;" />

**（2）逻辑移位**

&emsp;&emsp;逻辑移位对象为**无符号数**。

**移位规则**：逻辑左移时，高位丢失，低位添0；逻辑右移时，低位丢失，高位添0。

**（3）循环移位**

&emsp;&emsp;循环移位分为**带进位标志位CF的循环移位**和**不带进位标志位的循环移位**。

<img src="C:\Users\HP\Desktop\组成原理\2.2.2-2.png" alt="2.2.2-2" style="zoom:80%;" />

**特点**：循环移位操作适合将数据的低字节数据和高字节数据互换。



#### 2.2.3 强制类型转换

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2009-12,2010-14,2012-13</font>

1. **有符号$\rightarrow$无符号**

```c
int main() {
    short x = -4321;
    unsigned short y = (unsigned short)x;
    printf("x=%d, y=%u\n",x,y);
}
```

![2-2-1](C:\Users\HP\Desktop\组成原理\2-2-1.png)

其中，$x$为补码表示，$y$为无符号真值。

2. **无符号$\rightarrow$有符号**

```C
int main() {
    unsigned short x = 65535;
    short y = (short)x;
    printf("x=%u, y=%d\n",x,y);
}
```

在采用补码的机器上，$x=65535, y=-1$

3. **大字长$\rightarrow$小字长**

```C
int main() {
 	int x = 165537, u = -34991;			//int型占用4B
    short y = (short)x, v = (short)u;	//short占用2B
    printf("x=%d, y=%d\n",x,y);
    printf("u=%d, v=%d\n",u,v);
}
```

这段程序的结果为：

>$x = 165537, y = -31071$
>
>$u=-34991, v = 30545$

其中$x,y,u,v$的16进制表示分别为0x000286a1，0x86a1，0xffff7751，0x7751。

**原则总结：**当大字长变量向小字长变量强制类型转换时，系统把多余的高位字长部分直接截断，低位直接赋值。

4. **小字长$\rightarrow$大字长**

```c
int main() {
 	short x = -4321;
    int y = x;
    unsigned short u = (unsigned short)x;
    unsigned int v = u;
    printf("x=%d, y=%d\n",x,y);
    printf("u=%d, v=%d\n",u,v);
}
```

这段程序的结果为：

> $x = -4321, y = -4321$
>
> $u=61215, v = 61215$

其中$x,y,u,v$的16进制表示分别为0xef1f，0xffffef1f，0xef1f，0x0000ef1f

**原则总结：**当小字长变量向大字长变量强制类型转换时，不仅要使相应的位值相等，高位部分还会扩展为原数字的符号位。



### 2.3 浮点数的表示与运算

#### 2.3.1 浮点数的表示



1. **浮点数的表示格式**

&emsp;&emsp;通常，浮点数表示为
$$
N=r^E \times M
$$
其中，$r$是浮点数的阶码的底，与尾数的基数相同，通常$r=2$。$E$为阶码，$M$为尾数。

![2.3.1-1](C:\Users\HP\Desktop\组成原理\2.3.1-1.png)

&emsp;&emsp;阶码是整数，**阶符$J_f$和阶码的位数$m$共同反映浮点数的表示范围及小数点的实际位置**。数符$S_f$代表浮点数的符号，**尾数的位数$n$反映浮点数的精度**。

2. **规格化浮点数**

- **左规**：当浮点数运算的结果为非规格化时要进行规格化处理，将尾数左移一位，阶码减1(基数为2时)。**左规可能要进行多次**。
- **右规**：当浮点数运算的结果尾数出现溢出(双符号为01或10)时，将尾数算术右移一位、阶码加1(基数为2时)。**需要右规时，只需要进行一次**。

规格化浮点数的尾数$M$应满足条件$1/r \le |M| \le 1$。

<img src="C:\Users\HP\Desktop\组成原理\2.3.1-2.png" alt="2.3.1-2" style="zoom:85%;" />

**【注】**

- 当浮点数尾数的基数为2时，原码规格化数的尾数最高位一定为1，补码规格化数的尾数最高位一定与尾数符号位相反。
- 当浮点数尾数的基数为4时，原码规格化形式的尾数最高两位不全为0。
- 当浮点数尾数的基数为8时，原码规格化形式的尾数最高三位不全为0。

4. **IEEE 754 标准**

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2011-13,2012-14,2013-13，2014-14</font>

<img src="C:\Users\HP\Desktop\组成原理\2.3.1-3.png" alt="2.3.1-3" style="zoom:85%;" />

&emsp;&emsp;IEEE 754 标准规定了常用的浮点格式有短浮点数(单精度、float型)、长浮点数(双精度、double型)、临时浮点数

<img src="C:\Users\HP\Desktop\组成原理\2.3.1-4.png" alt="2.3.1-4" style="zoom:80%;" />

【注】**短浮点数与长浮点数都采用隐含尾数最高数位的方法，故可多表示一位数。临时浮点数又称扩展精度浮点数，无隐含位**。

> 例如，$(12)_{10}=(1100)_2$，将它规格化后结果为$1.1 \times 2^3$，其中整数部分“1”将不存储在23位尾数内。

&emsp;&emsp;IEEE 754标准中，规格化的短浮点数的真值为
$$
(-1)^s \times 1.M \times2^{E-127}
$$

&emsp;&emsp;规格化长浮点数的真值为
$$
(-1)^s \times 1.M \times2^{E-1023}
$$

- **IEEE 745浮点数的范围**

<img src="C:\Users\HP\Desktop\组成原理\2.3.1-5.png" alt="2.3.1-5" style="zoom:80%;" />

5. **定点、浮点表示的区别**

<img src="C:\Users\HP\Desktop\组成原理\2.3.1-6.png" alt="2.3.1-6" style="zoom:80%;" />





#### 2.3.2 浮点数的加减运算

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2009-13</font>

&emsp;&emsp;浮点数运算特点是**阶码运算和尾数运算分开进行**，浮点数的**加减运算一律采用补码**。浮点数的加减运算分以下几步：

1. **对阶**

**小阶向大阶对齐原则**：阶码小的尾数右移一位(基数为2)，阶加1，直到两个数的阶码相等为止。

2. **尾数求和**

将对阶后的尾数按定点数加减运算规则运算。

3. **规格化**

以双符号为例，当尾数大于0时，其补码规格化形式为
$$
[S]_{补}=00.1**
$$
当尾数小于0时，其补码规格化形式为
$$
[S]_{补}=11.0**
$$
可见，当尾数的最高位数值位与符号位不同时，即为规格化形式。规格化分为左规与右规两种：

**1）左规**：当尾数出现00.0&times;&times;&times;或11.1&times;&times;&times;时，需左规，即尾数左移1位，和的阶码减1，知道尾数为00.1&times;&times;&times;或11.0&times;&times;&times;。

**2）右规**：当尾数求和结果溢出(如尾数为10.&times;&times;&times;或01.&times;&times;&times;时，需右规，即尾数右移一位，和的阶码加1。

**【注】**

- 左规相当于乘2，右规相当于除2。
- $[-1/2]_{补}=1.1000$不是规格化数，需要左规一次，$[-1]_{补}=1.0000$才是规格化数。

4. **舍入**

在对阶和右规的过程中，可能会将尾数低位丢失，引起误差，影响精度。

**1）“0”舍“1”入法**：在尾数右移时，被移去的最高位为0时，则舍去；被移去的最高数值位为1时，则在尾数的末位加1。这样做可能使尾数又溢出，此时需要再做一次右规。

**2）恒置“1”法**：尾数右移时，不论丢掉的最高位数值位是“1”还是"0"，都使右移后的尾数末位恒置"1"。

5. **溢出判断**

- 当尾数出现10.&times;&times;&times;或01.&times;&times;&times;时，并不表示溢出，只能将此数右规后，再根据阶码来判断运算结果是否溢出。
- 浮点数的溢出与否是由阶码的符号决定的。以双符号位补码为例子，当阶码的符号位出现“01”时，即**阶码大于最大阶码时**，表示**上溢**。当阶码的符号位出现“10”时，即**阶码小于最小阶码时**，表示**下溢**。



## 第3章 存储系统

### 3.3 半导体随机存储器

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2010-16,2011-14,2013-29</font>



#### 3.3.2 SRAM和DRAM

1. **SRAM的工作原理**

&emsp;&emsp;通常把一个二进制的物理器件称为**存储元**，它是存储器的最基本的构建。地址码相同的多个存储元构成一个**存储单元**。若干存储单元构成一个**存储体**。

&emsp;&emsp;**静态随机存储器(SRAM)**的存储单元是用**双稳态触发器(六管MOS)**来记忆信息的，因此信息被读出后，它仍保留其原状态而不需再生**(非破坏性读出)**。但是，只要电源被切断，原来的信息便会丢失，故它属于**易失性半导体存储器**。

- **特点**：存储速度快，但集成度低，功耗大，所以一般用来组成**高速缓冲存储器**。

2. **DRAM的工作原理**

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2014-15</font>

&emsp;&emsp;与SRAM的存储原理不同，**动态随机存储器(DRAM)**是利用存储单元电路中**栅极电容上的电荷**来存储信息的，常见的DRAM的基本存储电路通常分为**三管式**和**单管式**。DRAM采用**地址复用技术**，地址线是原来的1/2，且地址信号分行、列两次传送。

- **特点**：相对于SRAM来说，DRAM具有容易集成、低价位、容量大和功耗低等优点，但DRAM的存取速度比SRAM的慢，一般用来组成**大容量主存系统**。

&emsp;&emsp;DRAM电容上的电荷一般只能维持1~2ms，因此即使电源不掉电，信息也会自动消失。为此，每隔一定时间必须刷新，通常取**2ms，这个时间为刷新周期**。常用的刷新方式有3种，集中刷新、分散刷新和异步刷新。

**（1）集中刷新**

&emsp;&emsp;指在一个刷新周期内，利用一段固定的时间，**依次对存储器所有行进行逐一再生，在此期间停止对存储器的读写操作**，称为**“死时间”**，又称为**“死区”**。

- **优点**：读写操作时不受刷新工作的影响，因此系统的存取速度较高
- **缺点**：在集中刷新期间(死区)不能访问存储器

**（2）分散刷新**

&emsp;&emsp;把**对每行的刷新分散到各个工作周期中**。这样，一个存储器的系统工作周期分为两部分：**前半部分正常读、写或保持；后半部分用于刷新某一行**。这种刷新方式增强了系统的存取周期，如存储芯片的存取周期为0.5us，则系统的存取周期为1us。

- **优点**：没有死区。
- **缺点**：加长了系统的存取周期，降低了整机的速度。

**（3）异步刷新**

&emsp;&emsp;异步刷新是前两种方法的结合，它既可以缩短“死时间”，又能充分利用最大刷新时间间隔为2ms的特点。具体做法是将**刷新周期除以行数**，得到两次刷新操作之间的时间间隔t，利用逻辑电路每隔时间t产生一次刷新请求。这样可以**避免使CPU连续等待过长的时间，而且减少了刷新次数，从根本上提高了整机的工作效率**。

**【注】**若将刷新安排在不需要访问存储器的译码阶段，则既不会加长存取周期，又不会产生“死时间”，这是分散刷新方式的发展，也称为**“透明刷新”**。

- **DRAM刷新需要注意的问题**

① **刷新对CPU是透明的**，即刷新不依赖于外部的访问；

② **动态RAM的刷新单位是行**，故刷新操作时仅需要行地址；

③ 刷新操作类似于读操作，但又有所不同。**刷新操作仅给栅极电容补充电荷，不需要信息输出**。另外，**刷新时不需要选片，即整个存储器中的所有芯片同时被刷新**。

**【注】**易失性存储器是指断点后数据会丢失。



4. **SRAM和DRAM的比较**

<img src="C:\Users\HP\Desktop\组成原理\3.3.2-1.png" alt="3.3.2-1" style="zoom:90%;" />

**【注】**计算机开机后，操作系统最终被加载到RAM。



#### 3.3.3 只读存储器ROM

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2012-16</font>

1. **只读存储器的特点**

ROM和RAM都是支持**随机存取**的存储器，其中SRAM和DRAM均为易失性存储器。而ROM中一旦有了信息，就不能轻易改变，即使掉电了也不会丢失，它在计算机系统中只供读出的存储器。

​		1）**结构简单**，位密度比可读可写存储器的高。

​		2）具有**非易失性**，所以可靠性高。

2. **ROM的类型**

   1）掩膜式只读存储器MROM

   2）一次可编程只读存储器PROM

   3）可擦除可编程只读存储器EPROM

   4）闪速存储器(Flash Memory)

   5）固态硬盘(Solid State Driver，SSD)





### 3.4 主存储器与CPU的连接

#### 3.4.2 主存容量的扩展

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2009-15,2010-15</font>

1. **位扩展(并联)**

&emsp;&emsp;位扩展是使存储芯片的数据位数与CPU的数据线数相等。如图，用8片8K&times;1位的RAM芯片组成8K&times;8位的存储器。8位RAM芯片的地址线$A_{12}$~$A_0$、片选信号$\overline{CS}$、读写控制线$\overline{WE}$都分别连在一起，每片的数据线依次作为CPU数据线的一位。

![3.4.2-1](C:\Users\HP\Desktop\组成原理\3.4.2-1.png)

2. **字扩展(串联)**

&emsp;&emsp;字扩展是指增加存储器中字的数量，而位数不变。如图，用4片16K&times;8位的RAM芯片组成64K&times;8位的存储器。4片RAM芯片的数据线$D_0$~$D_7$和读写控制线$\overline{WE}$都分别连在一起。将$A_{15}A_{14}$用作片选信号，$A_{15}A_{14}=00$时，译码输出端0有效，选最左边的1号芯片；$A_{15}A_{14}=01$时，译码输出端1有效，选中2号芯片，以此类推(在同一时间内只能有一个芯片被选中)

<img src="C:\Users\HP\Desktop\组成原理\3.4.2-2.png" alt="3.4.1-2" style="zoom:85%;" />

![3.4.1-3](C:\Users\HP\Desktop\组成原理\3.4.2-3.png)

3. **字位同时扩展法**

&emsp;&emsp;字位同时扩展既增加了存储字的数量，又增加了存储字长。如图，用用8片16K&times;4位的RAM芯片组成64K&times;8位的存储器。每两片构成一组16K&times;8位的存储器**(位扩展)**，4组便构成64K&times;8位**(字扩展)**。

![3.4.2-4](C:\Users\HP\Desktop\组成原理\3.4.2-4.png)



### 3.6 高速缓冲存储器Cache

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2009-21,2014-16</font>

<font color='#0099ff' size=5 face="黑体">大题：</font><font color='#FF0000' size=4 face="黑体">2010-44[重],2011-44,2013-43,2014-45</font>

#### 3.6.1 程序访问的局部性原理

- **时间局部性**：最近的未来要用到的信息，很可能是现在正在使用的信息，因为程序存在循环。
- **空间局部性**：最近的未来要用到的信息，很可能与现在使用的信息在存储空间上是邻近的，因为指令通常是顺序存放、顺序执行的。数据一般也是以向量、数组、表等形式簇聚第存储在一起的。

高速缓冲技术就是利用程序访问的局部性原理。



#### 3.6.2 Cache的基本工作原理

&emsp;&emsp;Cache位于存储器层次结构的顶层，**通常由SRAM构成**，其基本结构如图

<img src="C:\Users\HP\Desktop\组成原理\3.6.2-1.png" alt="3.6.2-1" style="zoom:80%;" />

&emsp;&emsp;Cache和主存都被划分成若干相等的块(Cache块又称Cache行)，每块由若干字节组成，块的长度称为块长(Cache行长)。由于Cache的容量远小于主存的容量，所以Cache中的块数要远少于主存中的块数，它保留主存中最活跃的若干块的副本。故Cache安照某种策略，预测CPU在未来一段时间内欲访存的数据，将其装入Cache。

&emsp;&emsp;当CPU发出读请求时，若访存地址在Cache中命中，就将此地址转换成Cache地址，直接对Cache进行读操作，与主存无关；若Cache不命中，则仍需访问主存，并把次字所在的块一次性地从主存调入Cache。若Cache已经满了，则根据某种替换算法，用这个块替换Cache中原来的某块信息。

【注】**CPU与Cache之间的数据交换以字位单位，而Cache与主存之间的数据交换以Cache为单位**。

- **Cache命中率**

$$
H = N_c/(N_c+N_m)
$$

其中$N_c$是Cache总命中次数，$N_m$是主存访问总次数。

- **Cache-主存系统平均访问时间**

$$
T_a = Ht_c+(1-H)t_m
$$

其中$t_c$为命中时的Cache访问时间，$t_m$为未命中时的访问时间，$1-H$表示未命中率。



#### 3.6.3 Cache和主存的映射方式

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2009-14</font>

1. **直接映射**

- **映象规则**：主存中一块只能映象到Cache特定的一块中。

- Cache地址**计算公式**：

$$
b=B \ \text{mod} \ C_b
$$

其中，$b$是Cache的块号(又称Cache的行号)，$B$是主存的块号，$C_b$是Cache中的总块数。

- **地址结构**：

![3.6.3-1](C:\Users\HP\Desktop\组成原理\3.6.3-1.png)

- **映象关系图**

<img src="C:\Users\HP\Desktop\组成原理\3.6.3-2.png" alt="3.6.3-2" style="zoom: 67%;" />

2. **全相联映射**

- **映象规则**：主存的任意一块可以映象到Cache中的任意一块。

- **地址结构**

  ![3.6.3-5](C:\Users\HP\Desktop\组成原理\3.6.3-5.png)

- **映象关系图**

<img src="C:\Users\HP\Desktop\组成原理\3.6.3-3.png" alt="3.6.3-3" style="zoom: 67%;" />

3. **组相联映射**

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2012-17</font>

- **映象规则**
  - 主存和Cache按同样大小划分成块和组
  - 主存和Cache组之间采用直接映象方式
  - 在两个对应的组内采用全相联映象方式

- **地址结构**

![3.6.3-6](C:\Users\HP\Desktop\组成原理\3.6.3-6.png)

- **映象关系图**

<img src="C:\Users\HP\Desktop\组成原理\3.6.3-7.png" alt="3.6.3-7" style="zoom: 67%;" />

- **例子【重点】**

<img src="C:\Users\HP\Desktop\组成原理\3.6.3-8.png" alt="3.6.3-8" style="zoom:80%;" />

<img src="C:\Users\HP\Desktop\组成原理\3.6.3-9.png" alt="3.6.3-9" style="zoom:80%;" />

<img src="C:\Users\HP\Desktop\组成原理\3.6.3-10.png" alt="3.6.3-10" style="zoom:80%;" />



### 3.7 虚拟存储器

<font color='#0099ff' size=5 face="黑体">大题：</font><font color='#FF0000' size=4 face="黑体">2011-44</font>

#### 3.7.2 页式虚拟存储器

&emsp;&emsp;以页为基本单位的虚拟存储器称为页式虚拟存储器。虚拟空间与主存空间都划分成同样大小的页，**主存的页称为实页，虚存的页称为虚页**。**页表是一张存放在主存中的虚页表和实页表对照表**，它记录程序的虚页调入主存时被安排在主存中的位置。

&emsp;&emsp;页表基址寄存器存放当前运行程序的页表起始地址，它和虚页号拼接成页表项地址，每个页表项记录与某个虚页对应的**虚页号**、**实页号**和**装入位**等信息。**装入位为“1”，表示该页面已经在主存中，将对应的实页号和虚拟地址中的页内地址拼接，得到完整地址**。装入位为“0”，表示该页面不在内存中，此时要启动I/O系统，把该页面从辅存调入主存后再供CPU使用。

<img src="C:\Users\HP\Desktop\组成原理\3.7.2-1.png" alt="3.7.2-1" style="zoom:80%;" />





#### 3.7.5 快表(TLB)

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2010-17,2011-16</font>

&emsp;&emsp;在页式或段式或段页式虚拟存储器中必须先去一次主存查页表或段表才取得数据。快表利用了**局部性原则**。快表存放在**高速缓冲器**中，**慢表(Page)**存放在**内存**中。快表只是慢表的一个副本，而且只存放了慢表中很少的一部分。

**【注1】**TLB是Page的一个很小副本，所以若TLB命中则Page一定命中。

**【注2】**在同时具有虚拟页式存储器(有TLB)和Cache的系统中，访问的顺序为：**TLB$\rightarrow$页表$\rightarrow$Cache$\rightarrow$主存**。CPU发出访存命令(逻辑地址)，先查找TLB和Page，将逻辑地址转换为物理地址，再查找相应的Cache块(与主存查找并行)。

**【注3】**若Cache命中，则说明所需页面已调入主存，Page必然命中，但TLB不一定命中；若Cache不命中，则并不能说明所需的页面未调入主存，和TLB和Page命中与否没有关系；若Page不命中，则说明所需页面未调入主存，当然Cache和快表也不会命中，执行调页策略。



## 第4章：指令系统

<font color='#0099ff' size=5 face="黑体">大题：</font><font color='#FF0000' size=4 face="黑体">2010-43,2013-44</font>

### 4.1 指令的基本格式

&emsp;&emsp;指令(又称为机器指令)是指示计算机执行某种操作的命令，是计算机运行的最小功能单位。一台计算机的所有指令的集合构成该机的指令系统，也称为指令集。

#### 4.1.1 指令的基本格式

<img src="C:\Users\HP\Desktop\组成原理\4.1.1-1.png" alt="4.1.1-1" style="zoom:80%;" />

- **操作码**：指出指令中该指令应该执行什么性质的操作和具有何种功能

- **地址码**：指出被操作的信息(指令或数据)的地址，包括参加运算的一个或多个操作数所在地址、运算结果的保存地址、程序的转移地址、被调用的子程序的入口地址等

1. **零地址指令**

<img src="C:\Users\HP\Desktop\组成原理\4.1.1-2.png" alt="4.1.1-2" style="zoom:80%;" />

2. **一地址指令**

<img src="C:\Users\HP\Desktop\组成原理\4.1.1-3.png" alt="4.1.1-3" style="zoom:80%;" />

3. **二地址指令**

<img src="C:\Users\HP\Desktop\组成原理\4.1.1-4.png" alt="4.1.1-4" style="zoom:80%;" />

若指令字长为32位，操作码占8位，两个地址码子段各占12位，则指令操作数的直接寻址范围为$2^{12}=4K$。

4. **三地址指令**

<img src="C:\Users\HP\Desktop\组成原理\4.1.1-5.png" alt="4.1.1-5" style="zoom:80%;" />

5. **四地址指令**

<img src="C:\Users\HP\Desktop\组成原理\4.1.1-6.png" alt="4.1.1-6" style="zoom:80%;" />



#### 4.1.2 定长操作码指令格式

&emsp;&emsp;定长操作码指令在指令字的最高位部分分配固定的若干位(定长)表示操作码，**一般n位操作码字段的指令系统最大能够表示$2^n$条指令**。



#### 4.1.3 扩展操作码指令格式

<img src="C:\Users\HP\Desktop\组成原理\4.1.1-7.png" alt="4.1.1-7" style="zoom:80%;" />

- **例子**

<img src="C:\Users\HP\Desktop\组成原理\4.1.1-8.png" alt="4.1.1-8" style="zoom:80%;" />

- **需注意的问题**

1）不允许短码是长码的前缀，即短操作码不能与长操作码的前面部分相同。

2）各指令的操作码一定不重复。



### 4.2 指令寻址方式

&emsp;&emsp;寻址方式是指寻找指令或操作数有效地址，即确定本条指令的数据地址及下一条待执行指令的地址的方法。

**【注1】A：形式地址**	**EA：有效地址**

**【注2】**\(A\)表示地址为A的数值，A既可以是寄存器编号，也可以是内存地址。对应(A)就是寄存器中的数值，或相应内存单元的数值。

**【注3】**EA=(A)意思是有效地址是地址A中的值。

#### 4.2.1 指令寻址和数据寻址

&emsp;&emsp;寻址方式分为指令寻址和数据寻址两大类。寻找下一条要执行的指令地址称为**指令寻址**；寻找操作数的地址称为**数据寻址**。

1. **指令寻址**

   **1）顺序寻址**：通过程序计数器(PC)加1(1个指令字长)，自动形成下一条指令的地址。

   **2）跳跃寻址：**所谓跳跃，是指下条指令的地址码不由程序计数器给出，而由本条指令给出下条下条指令地址的计算方式。

   【注】是否跳跃可能受到**状态寄存器**和**操作数**的控制，而跳跃到的地址分为**绝对地址**(由标记符直接得到)和**相对地址**(相对于当前指令地址的偏移量)，跳跃的结果是当前指令修改PC值，所以**下一条指令仍然通过程序计数器(PC)给出**。

2. **数据寻址**

&emsp;&emsp;数据寻址是指如何在指令中表示一个操作数的地址，如何用这种表示得到操作数或怎样计算出操作数的地址。

![4.2.1-1](C:\Users\HP\Desktop\组成原理\4.2.1-1.png)

#### 4.2.2 常见的数据寻址方式

1. **隐含寻址**

&emsp;&emsp;这种类型的指令不明显地给出操作数的地址，而在指令中隐含操作数的地址。

> 例：**单地址**的指令格式就不明显地在地址字段中指出第二个操作数的地址，规定**累加器(ACC)**作为第二个操作数地址。累加器(ACC)对单地址指令来说就是隐含寻址。

**优点**：缩短指令字长

**缺点**：增加存储器操作数或隐含地址的硬件。

<img src="C:\Users\HP\Desktop\组成原理\4.2.2-1.png" alt="4.2.2-1" style="zoom:80%;" />

2. **立即(数)寻址**

&emsp;&emsp;这种类型的指令的地址字段直接指出的不是操作数的地址，而是操作数的本身，又称为**立即数**。**数据采用补码的形式存放**。

**优点**：不访问主存，执行时间短。

**缺点**：A的位数限制了立即数的范围。

<img src="C:\Users\HP\Desktop\组成原理\4.2.2-2.png" alt="4.2.2-2" style="zoom:80%;" />

3. **直接寻址**

指令中的**形式地址A是操作数的真实地址EA**，即**EA=A**。

**优点**：简单，指令仅访问一次主存。

**缺点**：A的位数决定了该指令操作数的寻址范围，操作数的地址不易修改。

<img src="C:\Users\HP\Desktop\组成原理\4.2.2-3.png" alt="4.2.2-3" style="zoom:80%;" />

4. **间接寻址**

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2011-16</font>

&emsp;&emsp;**间接寻址是相对于直接寻址而言的**，指令的地址字段给出的形式地址不是操作数地址，而是操作数有效地址所在的存储单元，即**操作数地址的地址**，即**EA = (A)**。间接寻址可以是一次间接寻址，也可以是多次间接寻址。

**优点**：可扩大寻址范围(**有效地址EA的位数大于形式地址A的位数**)，便于编制程序(**用间接寻址可方便完成子程序的返回**)

**缺点**：指令在执行阶段需要多次访存，增大了时间开销。

<img src="C:\Users\HP\Desktop\组成原理\4.2.2-4.png" alt="4.2.2-4" style="zoom:80%;" />

5. **寄存器寻址**

&emsp;&emsp;寄存器寻址是指在指令字重直接给出操作数所在的寄存器编号，即$EA=R_i$，其操作数在$R_i$所指的寄存器内。

**优点**：不需要访问主存，执行速度快，**支持向量/矩阵运算**。

**缺点**：寄存器价格昂贵，计算机中的寄存器个数有限。

6. **寄存器间接寻址**

&emsp;&emsp;寄存器间接寻址是指在寄存器$R_i$中给出的不是操作数，而是操作数所在主存单元的地址，即$EA=(R_i)$。

**优点**：与一般间接寻址相比速度更快。

**缺点**：需要访问主存

<img src="C:\Users\HP\Desktop\组成原理\4.2.2-5.png" alt="4.2.2-5" style="zoom:80%;" />

7. **相对寻址**

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2009-16</font>

&emsp;&emsp;相对寻址是把程序计数器(PC)的内容加上形式地址A而形成的操作数的有效地址，即               **EA=(PC)+A**，其中A是相对于当前指令地址的位移量，可正可负，**补码表示**。

**优点**：操作数的地址不是固定的，它随PC值的变化而变化，且与指令之间总是相差一个固定值，因此**便于程序的浮动**。**相对寻址广泛利用于转移指令**。

**【注】**对于转移指令JMP A，当CPU从存储器中取出一个字节时，会自动执行(PC)+1->PC。若转移指令的地址为X，且占2B，在取出该指令后，PC的值会自增2，即(PC) = X + 2，这样在执行完该指令后，会自动跳转到X+2+A的地址继续执行。

<img src="C:\Users\HP\Desktop\组成原理\4.2.2-6.png" alt="4.2.2-6" style="zoom:80%;" />

8. **基址寻址**

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2014-17</font>

&emsp;&emsp;基址寻址是将CPU中的**基址寄存器(BR)**的内容加上指令格式中的形式地址A而形成操作数的有效地址。即**EA = (BR) + A**。其中基值寄存器既可以采用专用寄存器，又可以采用通用寄存器。

**优点**：可扩大寻址范围(**基址寄存器的位数大于形式地址A的位数**)，用户可以不用考虑自己的程序存于主存的哪个空间区域，有利于**多道程序的设计**，可用于**编制浮动程序**。

**缺点**：偏移量(形式地址A)的位数较短。

**【注1】**基址寄存器是**面向操作系统**的，其内容由操作系统或管理员确定，主要用于**解决程序逻辑空间与存储器的物理空间的无关性**。

**【注2】在程序执行的过程中，基址寄存器的内容不变(作为基地址)，形式地址可变(作为偏移量)**。采用通用寄存器时，可由用户决定哪个寄存器作为基址寄存器，但其内容仍然是由操作系统确定。

<img src="C:\Users\HP\Desktop\组成原理\4.2.2-7.png" alt="4.2.2-7" style="zoom:80%;" />

9. **变址寻址**

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2013-17</font>

&emsp;&emsp;变址寻址是指有效地址EA等于指令字中的形式地址A与**变址寄存器(IX)**的内容之和，即                 **EA = (IX) + A**。其中IX可为专业寄存器，也可以是通用寄存器。

**优点**：可扩大寻址范围(变址寄存器的位数大于形式地址A的位数)，**常用于数组处理**，可设定A为数组的首地址。**特别适合编制循环程序**。偏移量(变址寄存器IX)的位数足够以表示整个存储空间。

**【注】**变址寄存器是**面向用户的**，在程序执行的过程中，**变址寄存器可由用户改变(作为偏移量)，形式地址A不变(作为基地址)**。

<img src="C:\Users\HP\Desktop\组成原理\4.2.2-8.png" alt="4.2.2-8" style="zoom:80%;" />

10. **堆栈寄存器**

&emsp;&emsp;堆栈是存储器(或专用寄存器组)中一块特定的、按后进先出(LIFO)原则管理的存储区，该存储区中被读/写单元的地址是用一个特定的寄存器给出的，该寄存器为**堆栈指针(SP)**。堆栈可分为**硬堆栈**和**软堆栈**两种。

&emsp;&emsp;**寄存器堆栈又称为硬堆栈**。寄存器堆栈的成本比较高，不适合做大容量的堆栈；而从**主存划分一段区域做堆栈**是最常用的方法，这种堆栈称为**软堆栈**。

**【注】**采用堆栈结构的计算机系统中，**大部分指令表面上都表现为无操作数指令的形式**，因为操作数地址都隐含使用了SP。通常情况下，在读/写堆栈中的一个单元的前后都伴有自动完成对SP内容的增量或减量操作。

<img src="C:\Users\HP\Desktop\组成原理\4.2.2-9.png" alt="4.2.2-9" style="zoom:80%;" />



### 4.3 CISC和RISC的基本概念

#### 4.3.2 精简指令系统计算机(RISC)

<img src="C:\Users\HP\Desktop\组成原理\4-3-1.png" alt="4-3-1" style="zoom:80%;" />

#### 4.3.3 CISC和RISC的比较

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2009-17</font>

<img src="C:\Users\HP\Desktop\组成原理\4-3-2.png" alt="4-3-2" style="zoom:80%;" />



## 第5章 中央处理器

### 5.1 CPU的功能和基本结构

#### 5.1.1 CPU的功能

- **指令控制**：完成取指令、分析指令和执行指令的操作，即程序的顺序控制。
- **操作控制**：CPU管理并产生由内存取出的每条指令的操作信号，把各种操作信号送往相应的部件，从而控制这些部件按指定的要求进行动作。
- **时间控制**：为每条指令按时间顺序提供应有的控制信号。
- **数据加工**：对数据进行算术和逻辑运算。
- **中断处理**：对计算机运行过程中出现的异常情况和特殊请求进行处理。

#### 5.1.2 CPU的基本结构部

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2010-18,2011-17</font>

<img src="C:\Users\HP\Desktop\组成原理\5.1.2-1.png" alt="5.1.2-1" style="zoom:90%;" />

1. **运算器**

&emsp;&emsp;运算器接收从控制器送来的命令并执行相应的动作，对数据进行加工和处理，它是对数据进行加工处理的中心。

**1）算术逻辑单元(ALU)**：主要功能是进行算术/逻辑运算。

**2）暂存寄存器**：用于暂存从主存读来的数据，该数据不能存放在通用寄存器中，否则会破坏其原有的内容。**暂时寄存器对应用程序员是透明的**。

**3）累加寄存器(ACC)**：它是一个通用寄存器，用于暂时存放ALU运算的结果信息，可以作为加法运算的一个输入端。

**4）通用寄存器组**：如AX、BX、CX、DX、SP等，用于存放操作数(包括源操作、目的操作数及中间结果)和各种地址信息。SP是堆栈指针，用于指示栈顶的地址。

**5）程序状态寄存器(PSW)**：保留由算术逻辑运算指令或测试指令的结果而建立的各种状态信息，如**溢出标志(OF)、符号标志(SF)、零标志(ZF)、进位标志(CF)**等。PSW中的这些位参与并决定微操作的形成。

**6）移位器**：对操作数或运算结果进行移位运算。

**7）计数器(CT)**：控制乘除运算的操作步数。

2. **控制器**

&emsp;&emsp;控制器是整个系统的指挥中枢，在控制器的控制下，使运算器、存储器和输入/输出设备等功能部件构成一个有机的整体，根据指令的要求指挥全机协调工作。

&emsp;&emsp;控制器的基本功能是执行指令，**每条指令的执行是由控制器发出的一组微操作实现的**。

**1）程序计数器(PC)**：用于指出下一条指令在主存中的存放地址。CPU根据PC的内容去主存中取指令。因程序中指令通常是顺序执行的，所以**PC有自增功能**。

**2）指令寄存器(IR)**：用于保存当前正在执行的那条指令。

**3）指令译码器**：仅对操作字段进行译码，向控制器提供特定的操作信号。

**4）存储器地址寄存器(MAR)**：用于存放所要访问的主存单元的地址。

**5）存储器数据寄存器(MDR)**：用于存放向主存写入的信息或从主存中读出信息。

**6）时序系统**：用于产生各种时序信号，它们都由统一时钟(CLOCK)分频得到。

**7）微操作信号发生器**：根据IR的内容(指令)、PSW的内容(状态信息)及时序信号，产生控制整个计算机系统所需的各种控制信号，其结构有**组合逻辑**和**存储逻辑**两种。

【注】CPU内部寄存器分为两类：一类是**用户可见的寄存器**，可对这类寄存器编程，如**通用寄存器**、**程序状态寄存器(PSW)**，**程序计数器(PC)**；另一类是**用户不可见的寄存器**，对用户是透明的，不可对这类寄存器进行编程，如**存储器地址寄存器(MAR)**、**存储器数据寄存器(MDR)**、**指令寄存器(IR)**。



### 5.2 指令的执行过程

#### 5.2.1 指令周期

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2009-11,2011-19</font>

1. **概念**

&emsp;&emsp;CPU从主存中每取出并执行一条指令所需的全部时间称为**指令周期**，即CPU完成一条指令的时间。

&emsp;&emsp;指令周期常用若干个**机器周期**来表示，一个机器周期又包含若干**时钟周期**(也称为**节拍**或**T周期**，它是CPU操作的最基本单位)。每个指令周期内的机器周期数可以不等，每个机器周期内的节拍数也可以不等。
$$
\begin{align}
机器周期 &= 主存周期 \\
时钟周期 &= 计算机主频的倒数 \\
计算机主频 &= 1s时钟周期数
\end{align}
$$



<img src="C:\Users\HP\Desktop\组成原理\5.2-1.png" alt="5.2-1" style="zoom:80%;" />

<img src="C:\Users\HP\Desktop\组成原理\5.2.1-2.png" alt="5.2.1-2" style="zoom:80%;" />







### 5.3 数据通路的功能和基本结构



### 5.4 控制器的功能和工作原理

#### 5.4.1 控制器的结构和功能

<img src="C:\Users\HP\Desktop\组成原理\5.4.1-1.png" alt="5.4.1-1" style="zoom:80%;" />

控制器包括**指令寄存器IR**和**程序计数器PC**，它是计算机系统的指挥中心，控制器主要功能有：

1）从主存取出一条指令，并指出下一条指令在主存中的位置。

2）对指令进行译码或测试，产生相应的操作控制信息，以便启动规定的动作。

3）指挥控制CPU、主存、输入和输出设备之间的数据流动方向。

#### 5.4.2 硬布线控制器

<font color='#0099ff' size=5 face="黑体">大题：</font><font color='#FF0000' size=4 face="黑体">2009-44</font>

1. **硬布线控制单元图**

&emsp;&emsp;指令的操作码是决定控制单元发出不同操作命令(控制信号)的关键。CU的输入信号如下：

1）经指令译码器产生的指令信息。

2）时序系统产生的机器周期信号和节拍信号。

3）来自执行单元的反馈信息即标志。

<img src="C:\Users\HP\Desktop\组成原理\5.4.2-1.png" alt="5.4.2-1" style="zoom:80%;" />

2. **硬布线控制器的时序系统及微操作**<img src="C:\Users\HP\Desktop\组成原理\5.4.2-2.png" alt="5.4.2-2" style="zoom:80%;" /><img src="C:\Users\HP\Desktop\组成原理\5.4.2-3.png" alt="5.4.2-3" style="zoom:80%;" />

3. **CU的控制方式**

   1）同步控制方式	2）异步控制方式	3）联合控制方式



#### 5.4.3 微程序控制器

&emsp;&emsp;微程序设计思想是将每条机器指令编写成一个微程序，每个微程序包含若干个微指令，每个微指令对应一个或几个微操作命令。目前，**大多数计算机都采用微程序设计技术**。

1. **微程序控制的基本概念**

1）**微命令**和**微操作**：一条机器指令可分解成一个微操作系列，这些**微操作是计算机中最基本的、不可再分解的操作**。在微程序控制的计算机中，将**控制部件向执行部件发出各种控制命令称为微命令**，它是构成控制序列的最小单位。**微命令是微操作的控制信号，微操作是微命令的执行过程**。

**【注】**在组合逻辑控制器中也有微命令和微操作两个概念，它们并非是微程序控制器专有的。

2）**微指令**与**微周期**：微指令是若干微命令的集合。存放微程序指令的控制存储器的单元地址称为微地址。微指令通常至少包含两大部分信息：

​	① **操作控制字段**：又称为微操作码字段，用于产生某一步操作所需的各种操作控制信号。

​	② **顺序控制字段**：又称微地址码字段，用于控制产生下一条要执行的微指令地址。

3）**主存储器**与**控制存储器**：主存储器用于存放程序和数据，在CPU外部，用RAM实现；控制存储器(CM)用于存放微程序，在CPU内部，用ROM实现。

4）**程序**与**微程序**：程序是指令的有序集合，用于完成特定的功能；微程序是微指令的有序集合，**一条指令的功能由一段微程序来实现**。

**【注】微程序是不面向用户的**，它是由计算机设计者事先编制好并存放在控制存储器中的。程序是面向用户的，是由软件设计人员事先编制好放在主存或辅存的。

- **注意区分的几个寄存器**

  ① **地址寄存器(MAR)**：用于存放主存的读/写地址。

  ② **微指令寄存器(CMAR)**：用于存放控制存储器的读/写指令的地址。

  ③ **指令寄存器(IR)**：用于存放从主存中读出的指令。

  ④ **微指令寄存器(CMDR)**：用于存放从控制存储器中取出的微指令。



2. **微程序控制器的组成和工作过程**

**（1）微程序控制器的基本结构**

​	① **控制存储器**：它是微程序控制器的核心部件，用于存放各指令对应的微程序。

​	② **微指令寄存器(CMDR)**：用于存放从CM中取出的微指令，它的位数同微指令字长相等。

​	③ **微地址形成部件**：用于产生初始微地址和后继微地址，以保证微指令的连续执行。

​	④ **微地址寄存器(CMAR)**：接收微地址形成部件送来的微地址，为在CM中读取微指令做准备。

<img src="C:\Users\HP\Desktop\组成原理\5.4.3-1.png" alt="5.4.3-1" style="zoom:80%;" />

**（3）微程序和机器指令**

&emsp;&emsp;通常，一条机器指令对应一个微程序。**由于任何一条机器指令的取指令操作都是相同的，因此可以将取指令操作的微命令统一编成一个微程序**，这个微程序只负责将指令从主存单元中取出并送至寄存器。

**【注】**若指令系统中具有**n**种机器指令，则控制寄存器中的微程序数至少是**n+1(1为公共取指微操作)**。



3. **微指令的编码方式**

**（1）直接编码(直接控制)方式**

&emsp;&emsp;直接编码法无须进行译码，微指令的微命令字段中每位都代表一个微命令。设计微指令时，选用或不选用某个微命令，只要将表示该微命令对应位设置成1或0即可。

**优点**：简单、直观、执行速度快，操作并行性好。

**缺点**：微指令字长过长，n个微命令就要求微指令的操作字段有n位。

<img src="C:\Users\HP\Desktop\组成原理\5.4.3-2.png" alt="5.4.3-2" style="zoom:80%;" />

**（2）字段直接编码方式**

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2012-18</font>

&emsp;&emsp;将微指令的微命令字段分成若干小字段，把**互斥性微命令组合在同一字段中**，把**相容性微命令组合在不同字段中**，每个字段独立编码。

- **微命令字段的分段原则**
  - 互斥性命令分别在同一段中，相容性微命令分别在不同段中
  - 每个小段中包含的信息位不能太多，否则将增加译码线路的复杂性和译码时间
  - 一般每个小段还要留出一个状态，表示本字段不发出任何微命令。因此，当某字段的长度为3时，最多只能表示7个互斥的微命令，**通常用000表示不操作**。

**优点**：可以缩短微指令字长

**缺点**：因为要通过译码电路后再发出微命令，因此执行速度慢

<img src="C:\Users\HP\Desktop\组成原理\5.4.3-3.png" alt="5.4.3-3" style="zoom:80%;" />

**（3）字段间接编码方式**

&emsp;&emsp;一个字段的某些微命令需由另一个字段中的某些微命令来解释，由于不是靠字段直接译码发出微命令，故称为字段间接编码，又称隐式编码。



4. **微指令的地址形成方式**

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2014-18</font>

后继地址的形成主要有以下两大基本类型：

1）**直接由微指令的下地址段给出(断定方式)**

2）**根据机器指令的操作码形成**

微指令序列地址形成方式还有以下几种：<img src="C:\Users\HP\Desktop\组成原理\5.4.3-4.png" alt="5.4.3-4" style="zoom: 80%;" />



5. **微指令的格式**

**1）水平型微指令**：从编码上看。直接编码、字段直接编码、字段间接编码和混合编码都属于水平型微指令。指令字中的一位对应一个控制信号，有输出时为1，否则为0。**一条水平型指令定义并执行几种并行的基本操作**。

<img src="C:\Users\HP\Desktop\组成原理\5.4.3-5.png" alt="5.4.3-5" style="zoom:80%;" />

**优点**：微程序短，执行速度快

**缺点**：微指令长，编写微程序比较麻烦

**2）垂直型微指令**：垂直型微指令的特点是采用类似机器指令操作码方式，在微指令中设置操作码字段，采用微操作码编译法，由微操作码规定微指令的功能。**一条垂直型微指令只能定义并执行一种基本操作**。

<img src="C:\Users\HP\Desktop\组成原理\5.4.3-6.png" alt="5.4.3-6" style="zoom: 80%;" />

**优点**：微指令短、简单、规整，便于编写微程序。

**缺点**：微程序长，执行速度慢，工作效率低。

**3）混合型微指令**：在垂直型的基础上增加一些不太复杂的并行操作。微指令较短，仍便于编写；微程序也不长，执行速度快。

- **水平微指令 VS 垂直型微指令**

<img src="C:\Users\HP\Desktop\组成原理\5.4.3-7.png" alt="5.4.3-7" style="zoom:80%;" />



#### 5.4.4 微程序 VS 硬布线

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2009-19</font>

<img src="C:\Users\HP\Desktop\组成原理\5.4-1.png" style="zoom:75%;" />



### 5.5 指令流水线

#### 5.5.1 指令流水线的基本概念

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2009-18，2011-18</font>

<font color='#0099ff' size=5 face="黑体">大题：</font><font color='#FF0000' size=4 face="黑体">2012-44.2014-44</font>

3. **流水线方式的特点**

（1）把一个任务(一条指令或一个操作)分解为**几个有联系的子任务**，每个子任务由一个专门的功能部件来执行，并依靠多个功能部件并行工作来缩短执行时间。

（2）流水线每个功能部件后面都要有一个**缓冲寄存器**，或称为锁存器，其作用是保存流水段的执行结果，供给下一流水段使用。

（3）流水线中各个**功能段的时间应尽量相等**，否则会引起堵塞、断流。

（4）只有连续不断地提供同一种任务时才能发挥流水线的效率，所以流水线的中处理的必须是**连续任务**。

（5）流水线需要有**装入时间**和**排空时间**。装入时间是指第一个任务进入流水线到输出流水线的时间。排空时间是指最后一个任务进入流水线到输出流水线的时间。





#### 5.5.3 影响流水线的因素

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2010-19</font>

1. **结构相关(资源冲突)**

由于**多条指令在同一时刻争用同一资源**形成的冲突称为结构相关，有以下解决方案：

（1）前一指令访存时，使后一条相关指令(以及其后续指令)暂停一个时钟周期。

（2）单独设置数据存储器和指令存储器，使两项操作各自在不同的存储器中进行，这属于资源重配置。



2. **数据相关(数据冲突)**

&emsp;&emsp;数据相关是指在一个程序中，存在必须等前一条指令执行完才能执行后一条指令的情况，此时这两条指令记为数据相关。解决方法如下

（1）**暂停一个周期或多个周期**，直到数据相关问题消失后再执行。可分为**硬件阻塞(stall)**和**软件插入“NOP”指令**两种方法。

（2）**设置相关专用通路**，即不等前一条指令把结果写回寄存器组，下一条指令也不再读寄存器组，而直接把前一条指令ALU计算结果作为自己输入数据开始计算过程，使本来需要暂停的操作变得可以继续执行，这也称为**数据旁路技术**。

（3）**调整指令顺序**。



3. **控制相关(控制冲突、控制冒险)**

当流水线遇到**转移指令**和**其它改变PC值的指令**而造成断流时，会引起控制相关。解决方法如下：

（1）**对转移指令进行分支预测，尽早生成转移目标地址**。分支预测分**简单(静态)预测**和**动态预测**。静态预测总是预测条件不满足，即继续执行分支指令的后续指令。动态预测根据程序执行的历史情况，进行动态调整，有较高的预测准确率。

（2）预测转移成功和不转移成功两个控制流方向上的目标指令。

（3）加快和提前形成条件码。

（4）提高转移方向的猜准率。



#### 5.5.4 流水线的性能指标

1. **流水线的吞吐率**

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2013-18</font>

&emsp;&emsp;在指令级流水线中，吞吐率是指在单位时间内流水线所完成的任务数量，或输出结果的数量，计算流水线吞吐率(TP)的最基本的公式为
$$
TP= \frac{n}{T_k}
$$
式子中，$n$是任务数，$T_k$是处理完$n$个任务所用的时间。

- **例子**

&emsp;&emsp;对于一条$k$段流水线能够在$k+n-1$个时钟周期内完成$n$个任务。设时钟周期为$\Delta t$，则流水线的吞吐率为
$$
TP = \frac{n}{(k+n-1) \Delta t}
$$
当$n\rightarrow \infty$时，得到最大的吞吞吐率为$TP_\max = 1/\Delta t$





## 第6章 总线

### 6.1 总线概述

#### 6.1.1 总线基本概念

1. **总线的定义**

总线是一组能为多个部件分时共享的公共信息传送线路。**分时**和**共享**是总线的两个特征。

- **分时**：同一时刻只允许有一个部件向总线发送信息。
- **共享**：总线上可以挂接多个部件，各个部件之间相互交换的信息都可以通过这组线路分时共享。

2. **总线设备**

- **主设备**：总线的主设备是指获得总线控制权的设备。
- **从设备**：总线的从设备是指被主设备访问的设备，它只能响应从主设备发来的各种总线命令。

3. **总线特性**

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2012-34</font>

- **机械特征**：尺寸、形状
- **电气特性**：传输方向和有效的电平范围
- **功能特性**：每根传输线的功能
- **时间特性**：信号和时序的关系

4. **总线的猝发(突发)式传输方式**

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2014-20</font>

&emsp;&emsp;**猝发(突发)传送**是在一个总线周期中，可以传输多个存储地址连续的数据，即**一次传输一个地址和一批连续的数据**。

【注】**并行传输 VS 串行传输 VS 同步传输**

&emsp;&emsp;并行传输是在传输中**有多个数据位同时在设备之间进行的传输**；串行传输是指数据的二进制代码在一条物理信道上**以位为单位按时间顺序逐位传输的方式**；同步传输是指传输过程**由统一的时钟控制**。



#### 6.1.2 总线的分类

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2011-20</font>

1. **片内总线**

&emsp;&emsp;片内总线是芯片内部的总线，它是CPU芯片内部**寄存器与寄存器**之间、**寄存器与ALU**之间的公共连接线。

2. **系统总线**

&emsp;&emsp;系统总线是计算机系统内部各功能部件(CPU、主存、I/O)接口之间相互连接的总线。按系统传输信息的内容不同，又可分为3类，**数据总线**、**地址总线**和**控制总线**。

**1）数据总线**：用来传输各功能部件之间的数据信息，它是**双向**传输总线，其**位数与机器字长、存储字长有关**。

**【注】**数据总线上可以传输**指令**、**操作数**、**中断类型号**等。

**2）地址总线**：用来指出数据总线上的源数据或目的数据所在的主存单元或I/O端口的地址，它是**单向**传输总线，**地址总线的位数与主存地址空间的大小有关**。

**3）控制总线**：用来控制信息，包括CPU发出的控制命令和主存(或外设)返回CPU的反馈信息。

&emsp;&emsp;注意区分数据通路和数据总线：各个功能部件通过数据总线连接形成的数据传输路径称为数据通路。数据通路表示的是数据流的路径，而数据总线是承载媒体。

3. **通信总线**

&emsp;&emsp;通信总线是在**计算机系统之间**或**计算机系统与其他系统(如远程通信设备、测试设备)之间**传送信息的总线，**通信总线也称为外部设备**。



#### 6.1.4 总线的性能指标

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2009-20,2012-19.2014-19</font>

（1）**总线的传输周期**：指一次总线操作所需的时间(包括**申请阶段**、**寻址阶段**、**传输阶段**和**结束阶段**)，简称**总线周期**。总线传输周期通常由若干**总线时钟周期**构成。

（2）**总线时钟周期**：即**机器的时钟周期**。机器有一个统一的时钟，以控制整个计算机各个部件，总线也要受此时钟的控制。

（3）**总线的工作频率**：总线上各种操作的频率，为**总线周期的倒数**。实际上指1s内传送几次数据。若
$$
总线周期=N个时钟周期，则总线的工作频率=时钟频率/N
$$
（4）**总线的时钟频率**：即**机器的时钟频率**，它为**时钟周期的倒数**。

（5）**总线宽度**：又称**总线位宽**，它是总线上同时能传输的数据位数，通常指**数据总线的根数**，如32根称为32位总线。

（6）**总线的带宽**：可以理解为**总线的数据传输率**，即单位时间内总线上可以传输数据的位数，通常用每秒传送信息的字节数来衡量，单位可用**字节/秒(B/s)**。
$$
总线带宽=总线工作频率 \times (总线宽度/8)
$$
（7）**总线复用**：总线复用指一种信号线在不同的时间传输不同的信息，因此可以使用较少的线传输更多的信息，从而节省空间和成本。

（8）**信号线数**：**地址总线**、**数据总线**和**控制总线**3种总线数的总和称为信号线数。其中，总线的最主要性能指标为**总线宽度**、**总线(工作)频率**、**总线带宽**。

**【注】**总线**突发传输方式**传输数据的时间：$T=数据传输时间+地址传输时间$





### 6.4 总线标准

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2010-20,2012-20,2013-19</font>

#### 6.4.1 常见的总线标准

&emsp;&emsp;总线的标准有**ISA、EISA、VESA、PCI、PCI-Express、AGP、RS-232C、USB**等。它们主要的区别是总线宽度、带宽、时钟频率、寻址能力、是否支持突发传送等。

<img src="C:\Users\HP\Desktop\组成原理\6.4.1-1.png" alt="6.4.1-1" style="zoom:80%;" />

<img src="C:\Users\HP\Desktop\组成原理\6.4.1-2.png" alt="6.4.1-2" style="zoom:80%;" />



## 第7章 输入/输出系统



### 7.2 外部设备

&emsp;&emsp;外部设备也称为外围设备，是除主机外的能直接或间接与计算机交换信息的装置。最基本的外部设备主要有**键盘、鼠标、显示器、打印机、磁盘存储器和光盘存储器**等。

#### 7.2.1 输入设备

1. **键盘**

&emsp;&emsp;键盘是最常用的输入设备，通过它可以=发出命令或输入数据。

&emsp;&emsp;键盘输入信息可分为3个步骤：① 查出按下哪个键；② 将该键翻译成能被主机接收的编码，如ASCII码；③ 将编码传送给主机。

2. **鼠标**

&emsp;&emsp;鼠标是常用的定位输入设备，它分**机械式**和**光电式**两种。

&emsp;&emsp;工作原理：鼠标在平面上移动时，其底部传感器把运动的方向和距离检测出来，从而控制光标做相应的运动。

#### 7.2.2 输出设备

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2010-22</font>

1. **显示器**

- **分类**

**（1）按显示设备所用的显示器件分类**：阴极射线管(CRT)显示器、液晶显示器(LCD)、发光二极管(LED)显示器等。

**（2）按所显示的信息内容分类**：字符显示器、图形显示器、图像显示器。

**（3）按扫描方式不同**：光栅扫描显示器、随机扫描显示器。

- **屏幕大小**：以对角线的长度表示，常用的有12~29英寸等。
- **分辨率**：所能表示的像素个数，屏幕上的每个光点就是一个像素，以宽和高的像素乘积表示，如800&times;600、1027&times;768等。
- **灰度级**：灰度级是指黑白显示器中所显示的像素点的亮暗差别，在彩色显示器中则表现为颜色的不同，**灰度级越多，图像的层次越清楚、逼真**，典型的有8位(256级)、16位等。
- **刷新**：光点只能保持极短的时间就会消失，此时必须在光点消失前重新扫描显示一遍，这个过程称为刷新。
- **刷新频率**：指单位时间内扫描整个屏幕内容的次数。按照**人的视觉生理，刷新频率大于30HZ时才不会感到闪烁**，通常显示器的刷新频率为60~120HZ。
- **显示存储器(VRAM)**：也称为刷新存储器，为了不断提高刷新图像的信号，必须把一帧图像信息存储在刷新存储器中。其**存储容量由图像分辨率和灰度级决定的**，分辨率越高，灰度级越多，刷新存储容量越大。

$$
\begin{aligned}
& VRAM容量 = 分辨率 \times 灰度级位数 \\
& VRAM带宽 = 分辨率 \times 灰度级位数 \times 帧数
\end{aligned}
$$

- **液晶(LCD)显示器 VS 发光二极管(LED)显示器**

LED显示器在亮度、功耗、可视角度和刷新速率等方面更具优势。

2. **打印机**

- **分类**

**（1）按工作原理**：打击式和非打击式打印机

**（2）按工作方式**：点阵打印机、针式打印机、喷墨式打印机、激光打印机



### 7.3 I/O接口

I/O接口(I/O)控制器是**主机和外设之间的交接界面**，通过接口可以实现主机和外设之间的信息交换。

#### 7.3.1 I/O接口的功能

**（1）实现主机和外设的通信联络控制**：解决主机与外设时序的配合问题，协调不同工作速度的外设和主机之间的交换信息。

**（2）进行地址译码和设备选择**：CPU送来外设的地址码后，接口必须对地址进行译码以产生设备选择信息，使主机与指定的外设交换信息。

（3）**实现数据缓冲**：CPU与外设之间的速度往往不匹配，为消除速度差异，接口必须设置数据缓冲寄存器，用于数据的暂存，避免因速度不一致而丢失数据。

（4）**信号格式的转换**：电平转换、并/串或串/并转换、模/数或数/模转换等。

（5）**传送控制命令和状态信息**：CPU要启动某一外设时，通过接口中的**命令寄存器**向外设发送启动命令；外设准备就绪时，则将“准备好”状态信息送回接口中的**状态寄存器**，并反馈给CPU。外设向CPU提出中断请求和DMA请求时，CPU也应有相应的响应信号反馈给外设。

#### 7.3.2 I/O接口的基本结构

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2012-21</font>

<img src="C:\Users\HP\Desktop\组成原理\7.3.2-1.png" alt="7.3.2-1" style="zoom:85%;" />

- **内部接口**：内部接口与系统总线相连，实际上是**内存、CPU**相连。数据的传输方式只能是**并行传输**。
- **外部接口**：外部接口通过接口电缆与外设相连，外部接口的数据传输只能是**串行方式**。

I/O接口与CPU之间的I/O总线有**数据线**、**命令线**和**地址线**。

- **命令线**和**地址线**都是**单向传输**的，从CPU传送给I/O接口，而**I/O接口中的命令字**、**状态字**及**中断类型号**均是I/O接口发往CPU的，故只能通过**I/O总线的数据线**传输。

【注】**接口和端口是两个不同的概念**。端口是指接口电路中可以进行**读/写的寄存器**，若干端口加上相应的控制逻辑才可以组成接口。



#### 7.3.3 I/O接口的类型

从不同的角度看，I/O接口可以分为不同的类型。

1）**按数据传输方式**可分为**并行接口(一个字节或一个字的所有位同时传送)**和**串行接口(一位一位地传送)**，接口要完成数据格式的转换。

【注】这里所说的数据传送方式指的是**外设和接口一侧的传送方式**，而**在主机和接口一侧，数据总是并行传送的**。

2）**按主存访问I/O设备的控制方式**可分为**程序查询接口、中断接口和DMA接口**等。

3）**按功能选择的灵活性**可分为**可编程接口**和**不可编程接口**。



#### 7.3.4 I/O端口及其编址

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2014-21</font>

&emsp;&emsp;I/O端口是指接口电路中**可被CPU直接访问的寄存器**，主要有**数据端口、状态端口**和**控制端口**,若干端口加上相应的控制逻辑电路组成接口。通常，**CPU能对数据端口进行读写操作，但对状态端口只能执行读状态，对控制端口只能执行写操作**。

&emsp;&emsp;I/O端口要想被CPU访问，必须要有端口地址，每个端口对应一个端口地址。而对I/O端口的编制方式有**与存储器统一编制**和**独立编制**两种。

<img src="C:\Users\HP\Desktop\组成原理\7.3.4-1.png" alt="7.3.4-1" style="zoom:80%;" />



### 7.4 I/O方式

#### 7.4.1 程序查询方式

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2011-22</font>

&emsp;&emsp;信息交换的控制完全由主机执行程序实现，程序查询方式接口中设置一个**数据缓冲寄存器(数据端口)**和一个**设备状态寄存器(状态端口)**。主机进行I/O操作时，先发出查询信号，读取设备的状态并根据设备状态决定下一步操作究竟是进行数据传送还是等待。

- **程序查询方式的工作流程**

<img src="C:\Users\HP\Desktop\组成原理\7.4.1-1.png" alt="7.4.1-1" style="zoom:80%;" />

&emsp;&emsp;在这种控制方式下，CPU一旦启动I/O，就必须停止现行程序的运行，并在现行程序中插入一段程序。程序查询方式的特点是**CPU有“踏步”等待现象，CPU与I/O串行工作**。这种方式的**接口设计简单、设备量少**，但CPU在信息传送过程中要**花费很多时间来查询和等待**，而且**在一段时间内只能和一台外部设备交换信息，效率大大降低**。

<img src="C:\Users\HP\Desktop\组成原理\7.4.1-2.png" alt="7.4.1-2" style="zoom:80%;" />





#### 7.4.2 程序中断方式

<font color='#0099ff' size=5 face="黑体">大题：</font><font color='#FF0000' size=4 face="黑体">2009-43,2012-43</font>

##### 1. 程序中断的基本概念

<font color='#0099ff' size=5 face="黑体">选择：</font><font color='#FF0000' size=4 face="黑体">2014-22</font>

&emsp;&emsp;程序中断是指在计算机执行现行程序的过程中，出现某些急需处理的异常情况或特殊请求，**CPU暂时中止现行程序，而转去对这些异常情况或特殊情况进行处理，在处理完毕后CPU又自动返回到现行程序的断点处**，继续执行原程序。

- **程序中断的作用**

<img src="C:\Users\HP\Desktop\组成原理\7.4.2-3.png" alt="7.4.2-3" style="zoom:80%;" />

- **程序中断处理方式的思想**

&emsp;&emsp;CPU在程序中安排好某个时刻启动某台外设，然后CPU继续执行原来的程序，不需要像查询方式那样一直等待外设准备就绪。一旦外设完成数据传送的准备工作，就主动向CPU发出中断请求，请求CPU为自己服务。在可以响应中断的条件下，CPU暂停正在执行的程序，转去执行中断服务程序为外设服务，在中断服务程序中完成一次主机与外设之间的数据传送，传送完成后，CPU返回原来的程序。

<img src="C:\Users\HP\Desktop\组成原理\7.4.2-4.png" alt="7.4.2-4" style="zoom:80%;" />



##### 2. 程序中断方式工作流程

**（1）中断请求**

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2009-22</font>

中断请求是中断源向CPU发出中断请求信号。

① **内中断** VS **外中断**

- **外中断**：指来自处理器和内存以外的部件引起的中断，包括**I/O设备发出的I/O中断**、**外部信号中断(Esc建)**，以及各种定时器引起的时钟中断等。
- **内中断**：指在处理器和内存内部产生的中断，包括程序运算引起的各种错误，如地址非法、校验错、页面失效、存取访问控制错、算术操作溢出、数据格式非法、除数为零、非法指令、用户程序执行特权指令、分时系统中的时间片中断及用户态到核心态的切换等。

② **硬件中断** VS **软件中断**

- **硬件中断**：通过外部的硬件产生的中断。**硬件中断属于外中断**。
- **软件中断**：通过某条指令产生的中断，这种中断可以编程实现。**软件中断是内中断**。

③ **非屏蔽中断** VS **可屏蔽中断**

- **非屏蔽中断**：**非屏蔽中断是一种硬件中断**，这种中断通过不可中断请求NMI控制，不受中断标志位IF的影响，即使在关中断(IF = 0)的情况下也会被响应。
- **屏蔽中断**：**可屏蔽中断也是一种硬件中断**，此种中断通过中断请求标记触发器INTR控制，且受中断标志位IF的影响，在关中断情况下不接受中断请求。

也就是说，**可屏蔽中断和非屏蔽中断均是外部中断**。



**（4）中断隐指令**

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2012-22</font>

&emsp;&emsp;CPU响应中断后，经过某些操作，转去执行中断服务程序。这些操作是由**硬件直接实现**的，将它称为中断隐指令。

&emsp;&emsp;中断隐指令并**不是指令系统中一条真正的指令**，它没有操作码，所以中断隐指令是一种不允许也不可能为用户使用的特殊指令。它所完成的操作如下

①**关中断**：在中断服务程序中，为了保护中断现场(即CPU主要寄存器中的内容)期间不被新的中断所打断，必须关中断。

②**保存断点**：为保证在中断服务程序执行完毕后能正确返回到原来的程序，必须将原来的断点(即**程序计数器PC的内容**)保存起来。

③**引出中断服务程序**：引出中断服务程序的实质是，取出中断服务程序的入口地址并传送给程序计数器(PC)。



**（6）中断处理过程**

- **允许嵌套中断的处理流程**

<img src="C:\Users\HP\Desktop\组成原理\7.4.2-1.png" alt="7.4.2-1" style="zoom:90%;" />

- **不允许嵌套中断的处理流程**

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2010-21</font>

1）关中断 -> 2）保存断点 -> 3）识别中断源 -> 4）保护现场 -> 5）中断处理事件 -> 6）恢复现场 -> 7）开中断 -> 8）中断返回

**【注】**不允许嵌套中断的处理流程中**少了在恢复现场过程中的关中断和开中断**。



##### 3. 多重中断和中断屏蔽技术

<font color='#0099ff' size=5 face="黑体">考点：</font><font color='#FF0000' size=4 face="黑体">2011-21</font>

&emsp;&emsp;若CPU在执行中断服务程序的过程中，又出现了新的更高优先级的中断毕业，而CPU对新的中断请求不予响应，这种中断称为单重中断，如图7.7(a)。若CPU暂停现行的中断服务程序，转去处理新的中断响应，则这种中断称为多重中断，又称为中断嵌套，如图7.7(b)。

<img src="C:\Users\HP\Desktop\组成原理\7.4.2-2.png" alt="7.4.2-2" style="zoom:80%;" />

&emsp;&emsp;中断屏蔽技术主要用于多重中断。CPU要具备多重中断的功能，必须满足下列条件：

① 在中断服务程序中提前设置开中断指令。

② 优先级别高的中断源有权中断优先级别低的中断源。

&emsp;&emsp;每个中断源都有一个屏蔽触发器，1表示屏蔽该中断源的请求，0表示可以正常申请，所有屏蔽触发器组合在一起便构成了一个**屏蔽字寄存器**，屏蔽字寄存器的内容称为**屏蔽字**。



#### 7.4.3 DMA方式

<font color='#0099ff' size=5 face="黑体">大题：</font><font color='#FF0000' size=4 face="黑体">2009-43,2012-43</font>

&emsp;&emsp;DMA方式是一种**完全由硬件进行成组信息传送**的控制方式，它具有程序中断的优点，即**在数据准备阶段，CPU与外设并行工作**。DMA方式在外设和内存之间开辟一条“直接数据通道”，**信息传送不经过CPU(只有开始和结束的时候才需要CPU)**，降低了CPU在传送数据时的开销，因此称为直接存储器存取方式。

&emsp;&emsp;这种方式**适用于磁盘机、磁带机等高速设备大批量数据的传送**，它的硬件开销比较大。在DMA方式中，中断的作用仅限于故障和正常传送结束时的处理。

1. **DMA方式的特点**

<img src="C:\Users\HP\Desktop\组成原理\7.4.3-1.png" alt="7.4.3-1" style="zoom:80%;" />

2. **DMA控制器的组成**

&emsp;&emsp;在DMA方式中，**对数据传送过程进行控制的硬件**称为DMA控制器(DMA接口)。当I/O设备需要进行数据传送时，通过DMA控制器向CPU提出DMA传送请求，**CPU响应之后将让出系统总线**，由DMA控制器接管总线进行数据传送。其主要功能如下：

<img src="C:\Users\HP\Desktop\组成原理\7.4.3-2.png" alt="7.4.3-2" style="zoom:80%;" />

- **简单的DMA控制器结构图**

<img src="C:\Users\HP\Desktop\组成原理\7.4.3-3.png" alt="7.4.3-3" style="zoom:80%;" />

相关的部件：<img src="C:\Users\HP\Desktop\组成原理\7.4.3-4.png" alt="7.4.3-4" style="zoom:80%;" />

【注】**在DMA传送过程中，DMA控制器将接管CPU的地址总线、数据总线和控制总线**，CPU的主存控制信号被禁止使用。而当DMA传送结束后，将恢复CPU的一切权利并开始执行其操作，由此可见，**DMA控制器必须具备有控制总线的能力**。

3. **DMA的传输方式**

&emsp;&emsp;主存和DMA控制器之间有一条数据通路，因此主存和I/O设备之间交换信息时，不通过CPU。但当I/O设备和CPU同时访问主存时，可能发生冲突，为了有效地使用主存，DMA控制器与CPU通常采用以下3种方式使用主存。

<img src="C:\Users\HP\Desktop\组成原理\7.4.3-5.png" alt="7.4.3-5" style="zoom:80%;" />

<img src="C:\Users\HP\Desktop\组成原理\7.4.3-6.png" alt="7.4.3-6" style="zoom:78%;" />

4. **DMA的传送过程**

<img src="C:\Users\HP\Desktop\组成原理\7.4.3-7.png" alt="7.4.3-7" style="zoom:80%;" />

<img src="C:\Users\HP\Desktop\组成原理\7.4.3-8.png" alt="7.4.3-8" style="zoom:80%;" />

5. **DMA方式和中断方式的区别**

<img src="C:\Users\HP\Desktop\组成原理\7.4.3-9.png" alt="7.4.3-9" style="zoom:80%;" />

